#!/usr/bin/env bash
# CConductor - AI Research, Orchestrated
#
# Requires: Bash 4.0+

set -euo pipefail

VERSION="0.1.0"
CCONDUCTOR_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source CLI parser
# shellcheck disable=SC1091
source "$CCONDUCTOR_ROOT/src/utils/cli-parser.sh"

check_initialization() {
    # Check if user config directory exists (created by init.sh)
    # Platform-aware check
    if [ -f "$CCONDUCTOR_ROOT/src/utils/platform-paths.sh" ]; then
        # shellcheck disable=SC1091
        source "$CCONDUCTOR_ROOT/src/utils/platform-paths.sh"
        local config_dir
        config_dir=$(get_config_dir)
        
        # Check if config directory exists
        # We don't require configs to exist, just the directory
        if [ -d "$config_dir" ]; then
            return 0
        fi
    fi
    
    return 1
}

show_init_prompt() {
    cat <<EOF
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Welcome to CConductor! First-time setup required.        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

I will now:
  1. Check for dependencies (claude, jq, curl, bash, python3)
  2. Create user config directory (~/.config/cconductor/)
  3. Create OS-appropriate data directories
  4. Configure .gitignore to protect your data
  5. Make scripts executable
  6. Validate all configurations

This takes ~5 seconds. Run initialization? [Y/n] 
EOF
}

run_initialization() {
    local interactive="${1:-true}"
    
    if [ "$interactive" = "true" ]; then
        show_init_prompt
        read -r response
        
        case "${response:-y}" in
            [Yy]|[Yy][Ee][Ss]|"")
                echo ""
                "$CCONDUCTOR_ROOT/src/init.sh"
                ;;
            *)
                echo ""
                echo "Initialization cancelled. Run './cconductor --init' when ready."
                exit 0
                ;;
        esac
    else
        # Non-interactive mode
        "$CCONDUCTOR_ROOT/src/init.sh"
    fi
}

# Version management
show_version() {
    local version
    version=$(cat "$CCONDUCTOR_ROOT/VERSION" 2>/dev/null || echo "$VERSION")
    echo "CConductor v$version"
    
    # Trigger async update check
    if [ -f "$CCONDUCTOR_ROOT/src/utils/version-checker.sh" ]; then
        # shellcheck disable=SC1091
        source "$CCONDUCTOR_ROOT/src/utils/version-checker.sh"
        check_for_updates_async
    fi
}

# Self-update functionality
perform_update() {
    echo "ğŸ”„ Updating CConductor..."
    echo ""
    
    # Detect installation method
    if [ -d "$CCONDUCTOR_ROOT/.git" ]; then
        # Git installation
        echo "â†’ Detected git installation"
        echo "â†’ Pulling latest changes..."
        cd "$CCONDUCTOR_ROOT"
        git fetch origin
        git pull origin main
        
        echo "â†’ Running initialization..."
        "$CCONDUCTOR_ROOT/src/init.sh"
        
        local new_version
        new_version=$(cat "$CCONDUCTOR_ROOT/VERSION" 2>/dev/null || echo "unknown")
        echo ""
        echo "âœ… Updated to v$new_version"
    else
        # Installed via install.sh
        echo "â†’ Detected installer-based installation"
        echo "â†’ Downloading latest installer..."
        
        local temp_installer="/tmp/cconductor-install-$$.sh"
        if curl -fsSL "https://github.com/yaniv-golan/cconductor/releases/latest/download/install.sh" \
            -o "$temp_installer" 2>/dev/null; then
            chmod +x "$temp_installer"
            echo "â†’ Running installer..."
            bash "$temp_installer" "$CCONDUCTOR_ROOT"
            rm "$temp_installer"
            echo ""
            echo "âœ… Updated successfully"
        else
            echo "âœ— Failed to download installer"
            echo ""
            echo "Manual update:"
            echo "  curl -fsSL https://github.com/yaniv-golan/cconductor/releases/latest/download/install.sh | bash"
            exit 1
        fi
    fi
}

show_help() {
    cat <<EOF
ğŸ” CConductor v$VERSION - AI Research, Orchestrated

USAGE:
  cconductor <question>                 Start new research
  cconductor <question> --input-dir DIR Analyze local files with your research
  cconductor <question> --non-interactive  Skip plan confirmation (for automation)
  cconductor latest                     Show latest research session
  cconductor resume <session>           Continue previous research
  cconductor sessions                   List all research sessions
  cconductor status                     Check running research
  cconductor configure                  Show configuration files
  cconductor --update                   Update to latest version
  cconductor --check-update             Check for updates now
  cconductor --no-update-check          Disable update check for this run
  cconductor --init                     Run/re-run initialization
  cconductor --help                     Show this help
  cconductor --version                  Show version

OPTIONS:
  --input-dir DIR                  Directory with local files to analyze
                                   Supported: PDFs (.pdf), Markdown (.md), Text (.txt)
                                   PDFs are cached; text files are loaded into session
  --non-interactive, -y            Skip interactive plan confirmation
                                   Useful for automation and testing
                                   Note: Flag must come AFTER the question

EXAMPLES:
  # Basic research
  cconductor "What are the latest advances in CRISPR?"
  cconductor "SaaS market size 2024"
  
  # Non-interactive research (no confirmation prompts)
  cconductor "What are neural networks?" --non-interactive
  cconductor "What is quantum computing?" -y
  
  # Research with local materials
  cconductor "Analyze this pitch deck" --input-dir ./pitch-materials/
  cconductor "Summarize these reports" --input-dir ~/Documents/research/
  
  # Session management
  cconductor resume session_1759356338
  cconductor latest
  cconductor --init --yes               Run initialization non-interactively

CONFIGURATION:
  Config files are stored in OS-appropriate locations:
    â€¢ macOS:   ~/.config/cconductor/
    â€¢ Linux:   ~/.config/cconductor/
    â€¢ Windows: %APPDATA%\\CConductor\\

  Create custom configs:
    â€¢ ./src/utils/config-loader.sh init cconductor-config
    â€¢ ./src/utils/config-loader.sh init security-config
    â€¢ ./src/utils/config-loader.sh list    (see all configs)

  Add custom knowledge:
    â€¢ macOS:   ~/Library/Application Support/CConductor/knowledge-base-custom/
    â€¢ Linux:   ~/.local/share/cconductor/knowledge-base-custom/
    â€¢ Windows: %LOCALAPPDATA%\\CConductor\\knowledge-base-custom\\

RESULTS:
  Reports are saved to OS-appropriate data directories:
    â€¢ macOS:   ~/Library/Application Support/CConductor/research-sessions/
    â€¢ Linux:   ~/.local/share/cconductor/research-sessions/
    â€¢ Windows: %LOCALAPPDATA%\\CConductor\\research-sessions\\
  
  Use: ./src/utils/path-resolver.sh resolve session_dir (to find exact path)

DOCUMENTATION:
  Quick start:  docs/QUICK_REFERENCE.md
  User guide:   docs/USER_GUIDE.md
  Troubleshoot: docs/TROUBLESHOOTING.md
  README:       README.md

EOF
}

handle_research() {
    local question="$1"
    
    # Check initialization before running research
    if ! check_initialization; then
        run_initialization true
    fi
    
    # CRITICAL: Check for Claude Code CLI before doing ANY work
    if ! command -v claude &> /dev/null; then
        echo "" >&2
        echo "âŒ Error: Claude Code CLI not found" >&2
        echo "" >&2
        echo "CConductor requires Claude Code CLI to function." >&2
        echo "This is the AI agent runtime that powers the multi-agent system." >&2
        echo "" >&2
        
        # Check if npm is available
        if ! command -v npm &> /dev/null; then
            echo "First, install Node.js (includes npm):" >&2
            echo "" >&2
            echo "  macOS:" >&2
            if ! command -v brew &> /dev/null; then
                echo "    1. Install Homebrew:" >&2
                echo "       /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"" >&2
                echo "    2. Install Node.js:" >&2
                echo "       brew install node" >&2
            else
                echo "    brew install node" >&2
            fi
            echo "" >&2
            echo "  Ubuntu:" >&2
            echo "    curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -" >&2
            echo "    sudo apt-get install -y nodejs" >&2
            echo "" >&2
            echo "Then install Claude Code CLI:" >&2
        else
            echo "Install with:" >&2
        fi
        echo "  npm install -g @anthropic-ai/claude-code" >&2
        echo "" >&2
        echo "Requirements:" >&2
        echo "  â€¢ Node.js 18 or newer (provides npm)" >&2
        echo "  â€¢ Claude.ai or Console account (Pro/Max subscription or API credits)" >&2
        echo "" >&2
        echo "See: https://docs.anthropic.com/en/docs/claude-code/overview" >&2
        echo "" >&2
        exit 1
    fi
    
    # Check for --input-dir flag
    local input_dir=""
    if has_flag "input-dir"; then
        input_dir=$(get_flag "input-dir")
        
        # Validate input directory exists
        if [ ! -d "$input_dir" ]; then
            echo "Error: Input directory not found: $input_dir" >&2
            exit 1
        fi
        
        # Resolve to absolute path
        input_dir=$(cd "$input_dir" && pwd)
        
        echo "ğŸ“ Loading input files from: $input_dir"
        echo ""
        
        # Pass to cconductor-adaptive.sh via environment variable
        export CCONDUCTOR_INPUT_DIR="$input_dir"
    fi
    
    # Check for --non-interactive or -y flag
    if has_flag "non-interactive" || has_flag "y"; then
        export CCONDUCTOR_NON_INTERACTIVE=1
    fi
    
    # Call cconductor-adaptive.sh
    "$CCONDUCTOR_ROOT/src/cconductor-adaptive.sh" "$question"
    
    # Show update notification after research
    if [ "${CCONDUCTOR_NO_UPDATE_CHECK:-0}" != "1" ] && [ -f "$CCONDUCTOR_ROOT/src/utils/version-checker.sh" ]; then
        # shellcheck disable=SC1091
        source "$CCONDUCTOR_ROOT/src/utils/version-checker.sh"
        show_cached_notification || check_for_updates_async
    fi
}

main() {
    # Parse all CLI arguments
    parse_cli_args "$@"
    
    # Handle special flags first
    if has_flag "help" || has_flag "h"; then
        show_help
        return 0
    fi
    
    if has_flag "version" || has_flag "v"; then
        show_version
        return 0
    fi
    
    if has_flag "update"; then
        perform_update
        return 0
    fi
    
    if has_flag "check-update"; then
        if [ -f "$CCONDUCTOR_ROOT/src/utils/version-checker.sh" ]; then
            # shellcheck disable=SC1091
            source "$CCONDUCTOR_ROOT/src/utils/version-checker.sh"
            check_for_updates_sync
        else
            echo "Version checker not available"
            exit 1
        fi
        return 0
    fi
    
    if has_flag "no-update-check"; then
        export CCONDUCTOR_NO_UPDATE_CHECK=1
    fi
    
    if has_flag "init"; then
        if has_flag "yes" || has_flag "y"; then
            run_initialization false
        else
            run_initialization true
        fi
        return 0
    fi
    
    # Get first positional argument (command or research question)
    local command
    command=$(get_arg 0)
    
    # Handle empty command
    if [ -z "$command" ]; then
        show_help
        return 0
    fi
    
    # Handle commands
    case "$command" in
        resume)
            # Check initialization before resuming
            if ! check_initialization; then
                run_initialization true
            fi
            
            local session_id
            session_id=$(get_arg 1)
            if [ -z "$session_id" ]; then
                echo "Error: resume requires a session ID" >&2
                exit 1
            fi
            
            "$CCONDUCTOR_ROOT/src/cconductor-adaptive.sh" --resume "$session_id"
            
            # Show update notification after research
            if [ "${CCONDUCTOR_NO_UPDATE_CHECK:-0}" != "1" ] && [ -f "$CCONDUCTOR_ROOT/src/utils/version-checker.sh" ]; then
                # shellcheck disable=SC1091
                source "$CCONDUCTOR_ROOT/src/utils/version-checker.sh"
                show_cached_notification || check_for_updates_async
            fi
            ;;
        sessions|list)
            # Use the formatted list from cconductor-adaptive.sh
            "$CCONDUCTOR_ROOT/src/cconductor-adaptive.sh" --list
            ;;
        status)
            echo "Checking for running research sessions..."
            pgrep -fl "cconductor-adaptive" || echo "No active sessions"
            ;;
        latest)
            # Get session directory from path resolver (with fallback)
            local session_dir="$CCONDUCTOR_ROOT/research-sessions"
            if [ -f "$CCONDUCTOR_ROOT/src/utils/path-resolver.sh" ]; then
                # shellcheck disable=SC1091
                source "$CCONDUCTOR_ROOT/src/utils/path-resolver.sh" 2>/dev/null
                local resolved
                # Use return code instead of string check
                if resolved=$(resolve_path "session_dir" 2>/dev/null) && [ -n "$resolved" ]; then
                    session_dir="$resolved"
                fi
            fi
            
            if [ -f "$session_dir/.latest" ]; then
                LATEST_SESSION=$(cat "$session_dir/.latest")
                LATEST_PATH="$session_dir/$LATEST_SESSION"
                
                if [ -d "$LATEST_PATH" ]; then
                    echo "Latest session: $LATEST_SESSION"
                    echo "Location: $LATEST_PATH"
                    echo ""
                    
                    # Show session metadata if available
                    if [ -f "$LATEST_PATH/session.json" ]; then
                        local question
                        question=$(jq -r '.research_question // "N/A"' "$LATEST_PATH/session.json" 2>/dev/null || echo "N/A")
                        local status
                        status=$(jq -r '.status // "unknown"' "$LATEST_PATH/session.json" 2>/dev/null || echo "unknown")
                        local created
                        created=$(jq -r '.created_at // "N/A"' "$LATEST_PATH/session.json" 2>/dev/null || echo "N/A")
                        
                        echo "Question: $question"
                        echo "Status: $status"
                        echo "Created: $created"
                        echo ""
                    fi
                    
                    # Show knowledge graph summary if available
                    if [ -f "$LATEST_PATH/knowledge-graph.json" ]; then
                        local entities
                        local claims
                        local confidence
                        local gaps
                        entities=$(jq -r '.stats.total_entities // 0' "$LATEST_PATH/knowledge-graph.json" 2>/dev/null)
                        claims=$(jq -r '.stats.total_claims // 0' "$LATEST_PATH/knowledge-graph.json" 2>/dev/null)
                        confidence=$(jq -r '.confidence_scores.overall // 0' "$LATEST_PATH/knowledge-graph.json" 2>/dev/null)
                        gaps=$(jq -r '.stats.unresolved_gaps // 0' "$LATEST_PATH/knowledge-graph.json" 2>/dev/null)
                        
                        echo "Progress:"
                        echo "  â€¢ Entities: $entities"
                        echo "  â€¢ Claims: $claims"
                        echo "  â€¢ Confidence: $confidence"
                        echo "  â€¢ Unresolved gaps: $gaps"
                        echo ""
                    fi
                    
                    # Show report if exists
                    if [ -f "$LATEST_PATH/research-report.md" ]; then
                        echo "âœ“ Report available: $LATEST_PATH/research-report.md"
                        echo ""
                        echo "View with:"
                        echo "  cat $LATEST_PATH/research-report.md"
                        echo "  open $LATEST_PATH/research-report.md"
                        echo ""
                        echo "Resume with:"
                        echo "  ./cconductor resume $LATEST_SESSION"
                    else
                        echo "â³ Research in progress or not yet complete"
                        echo ""
                        echo "Resume with:"
                        echo "  ./cconductor resume $LATEST_SESSION"
                    fi
                else
                    echo "Error: Latest session directory not found: $LATEST_SESSION"
                    exit 1
                fi
            else
                echo "No research sessions yet. Start one with:"
                echo "  ./cconductor \"your research question\""
            fi
            ;;
        view-dashboard)
            # Get session directory (optional parameter)
            local session_arg
            session_arg=$(get_arg 1)
            local session_dir=""
            
            if [ -z "$session_arg" ]; then
                # No argument - use latest session
                local latest_file="$CCONDUCTOR_ROOT/research-sessions/.latest"
                if [ ! -f "$latest_file" ]; then
                    echo "Error: No active session found" >&2
                    echo "Run a research query first: ./cconductor \"your question\"" >&2
                    exit 1
                fi
                local session_id
                session_id=$(cat "$latest_file")
                session_dir="$CCONDUCTOR_ROOT/research-sessions/$session_id"
            elif [[ "$session_arg" == /* ]]; then
                # Absolute path provided
                session_dir="$session_arg"
            else
                # Session ID provided (with or without 'session_' prefix)
                local session_id="$session_arg"
                if [[ ! "$session_id" == session_* ]]; then
                    session_id="session_${session_id}"
                fi
                session_dir="$CCONDUCTOR_ROOT/research-sessions/$session_id"
            fi
            
            # Validate session directory exists
            if [ ! -d "$session_dir" ]; then
                echo "Error: Session directory not found: $session_dir" >&2
                exit 1
            fi
            
            # Check if dashboard exists, generate if needed
            local dashboard_file="$session_dir/dashboard.html"
            if [ ! -f "$dashboard_file" ]; then
                echo "Generating dashboard..."
                if ! bash "$CCONDUCTOR_ROOT/src/utils/dashboard-generator.sh" "$session_dir"; then
                    echo "Error: Failed to generate dashboard" >&2
                    exit 1
                fi
            fi
            
            # Generate dashboard metrics if missing
            if [ ! -f "$session_dir/dashboard-metrics.json" ]; then
                bash -c "source '$CCONDUCTOR_ROOT/src/utils/dashboard-metrics.sh' && generate_dashboard_metrics '$session_dir'" 2>/dev/null || true
            fi
            
            # Find an available port (8890-8899)
            local port=""
            for p in {8890..8899}; do
                if ! lsof -i ":$p" >/dev/null 2>&1; then
                    port=$p
                    break
                fi
            done
            
            if [ -z "$port" ]; then
                echo "Error: No available ports in range 8890-8899" >&2
                echo "Try: pkill -f 'http-server.*$port'" >&2
                exit 1
            fi
            
            # Start HTTP server in background using npx (comes with Node.js)
            echo "Starting HTTP server on port $port..."
            cd "$session_dir"
            npx --yes http-server -p "$port" --silent > /dev/null 2>&1 &
            local server_pid=$!
            
            # Save PID for potential cleanup
            echo "$server_pid" > "$session_dir/.dashboard-server.pid"
            
            sleep 2
            
            # Open in browser with session ID parameter (prevents caching issues)
            local session_id
            session_id=$(basename "$session_dir")
            local dashboard_url="http://localhost:$port/dashboard.html?session=$session_id"
            echo "âœ… Dashboard server started (PID: $server_pid)"
            echo "ğŸ“Š Opening: $dashboard_url"
            echo ""
            echo "To stop the server later:"
            echo "  kill $server_pid"
            echo "  or: pkill -f 'http-server.*$port'"
            echo ""
            
            if [[ "$OSTYPE" == "darwin"* ]]; then
                open "$dashboard_url"
            elif command -v xdg-open &> /dev/null; then
                xdg-open "$dashboard_url" &
            elif command -v explorer.exe &> /dev/null; then
                # WSL
                explorer.exe "$dashboard_url" 2>/dev/null
            else
                echo "Dashboard available at: $dashboard_url"
            fi
            ;;
        configure|config)
            echo "ğŸ”§ CConductor Configuration"
            echo ""
            
            # Get user config directory
            if [ -f "$CCONDUCTOR_ROOT/src/utils/config-loader.sh" ]; then
                # shellcheck disable=SC1091
                source "$CCONDUCTOR_ROOT/src/utils/config-loader.sh"
                
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                echo ""
                
                # Show user config location
                local user_config_dir
                user_config_dir=$(get_user_config_dir)
                echo "User Config Directory: $user_config_dir"
                echo ""
                
                # List configs
                "$CCONDUCTOR_ROOT/src/utils/config-loader.sh" list
                echo ""
                
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                echo ""
                echo "Create custom config:"
                echo "  ./src/utils/config-loader.sh init <config-name>"
                echo ""
                echo "Edit config:"
                echo "  vim $user_config_dir/<config-name>.json"
                echo ""
                echo "View differences:"
                echo "  ./src/utils/config-loader.sh diff <config-name>"
                echo ""
                echo "Get help:"
                echo "  ./src/utils/config-loader.sh help"
            else
                echo "Error: Config loader not found"
                exit 1
            fi
            ;;
        *)
            # Research question - use adaptive system with optional --input-dir
            handle_research "$command"
            ;;
    esac
}

main "$@"
