#!/usr/bin/env bash
# Delve - Deep Research, Done Right
#
# Requires: Bash 4.0+

set -euo pipefail

VERSION="0.1.0"
DELVE_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source CLI parser
# shellcheck disable=SC1091
source "$DELVE_ROOT/src/utils/cli-parser.sh"

check_initialization() {
    # Check if user config directory exists (created by init.sh)
    # Platform-aware check
    if [ -f "$DELVE_ROOT/src/utils/platform-paths.sh" ]; then
        source "$DELVE_ROOT/src/utils/platform-paths.sh"
        local config_dir=$(get_config_dir)
        
        # Check if config directory exists
        # We don't require configs to exist, just the directory
        if [ -d "$config_dir" ]; then
            return 0
        fi
    fi
    
    return 1
}

show_init_prompt() {
    cat <<EOF
┌─────────────────────────────────────────────────────┐
│ Welcome to Delve! First-time setup required.        │
└─────────────────────────────────────────────────────┘

I will now:
  1. Check for dependencies (jq, curl, bash)
  2. Create user config directory (~/.config/delve/)
  3. Create OS-appropriate data directories
  4. Configure .gitignore to protect your data
  5. Make scripts executable
  6. Validate all configurations

This takes ~5 seconds. Run initialization? [Y/n] 
EOF
}

run_initialization() {
    local interactive="${1:-true}"
    
    if [ "$interactive" = "true" ]; then
        show_init_prompt
        read -r response
        
        case "${response:-y}" in
            [Yy]|[Yy][Ee][Ss]|"")
                echo ""
                "$DELVE_ROOT/src/init.sh"
                ;;
            *)
                echo ""
                echo "Initialization cancelled. Run './delve --init' when ready."
                exit 0
                ;;
        esac
    else
        # Non-interactive mode
        "$DELVE_ROOT/src/init.sh"
    fi
}

# Version management
show_version() {
    local version=$(cat "$DELVE_ROOT/VERSION" 2>/dev/null || echo "$VERSION")
    echo "Delve v$version"
    
    # Trigger async update check
    if [ -f "$DELVE_ROOT/src/utils/version-checker.sh" ]; then
        source "$DELVE_ROOT/src/utils/version-checker.sh"
        check_for_updates_async
    fi
}

# Self-update functionality
perform_update() {
    echo "🔄 Updating Delve..."
    echo ""
    
    # Detect installation method
    if [ -d "$DELVE_ROOT/.git" ]; then
        # Git installation
        echo "→ Detected git installation"
        echo "→ Pulling latest changes..."
        cd "$DELVE_ROOT"
        git fetch origin
        git pull origin main
        
        echo "→ Running initialization..."
        "$DELVE_ROOT/src/init.sh"
        
        local new_version=$(cat "$DELVE_ROOT/VERSION" 2>/dev/null || echo "unknown")
        echo ""
        echo "✅ Updated to v$new_version"
    else
        # Installed via install.sh
        echo "→ Detected installer-based installation"
        echo "→ Downloading latest installer..."
        
        local temp_installer="/tmp/delve-install-$$.sh"
        if curl -fsSL "https://github.com/yaniv-golan/delve/releases/latest/download/install.sh" \
            -o "$temp_installer" 2>/dev/null; then
            chmod +x "$temp_installer"
            echo "→ Running installer..."
            bash "$temp_installer" "$DELVE_ROOT"
            rm "$temp_installer"
            echo ""
            echo "✅ Updated successfully"
        else
            echo "✗ Failed to download installer"
            echo ""
            echo "Manual update:"
            echo "  curl -fsSL https://github.com/yaniv-golan/delve/releases/latest/download/install.sh | bash"
            exit 1
        fi
    fi
}

show_help() {
    cat <<EOF
🔍 Delve v$VERSION - Deep Research, Done Right

USAGE:
  delve <question>                 Start new research
  delve <question> --input-dir DIR Analyze local files with your research
  delve <question> --non-interactive  Skip plan confirmation (for automation)
  delve latest                     Show latest research session
  delve resume <session>           Continue previous research
  delve sessions                   List all research sessions
  delve status                     Check running research
  delve configure                  Show configuration files
  delve --update                   Update to latest version
  delve --check-update             Check for updates now
  delve --no-update-check          Disable update check for this run
  delve --init                     Run/re-run initialization
  delve --help                     Show this help
  delve --version                  Show version

OPTIONS:
  --input-dir DIR                  Directory with local files to analyze
                                   Supported: PDFs (.pdf), Markdown (.md), Text (.txt)
                                   PDFs are cached; text files are loaded into session
  --non-interactive, -y            Skip interactive plan confirmation
                                   Useful for automation and testing
                                   Note: Flag must come AFTER the question

EXAMPLES:
  # Basic research
  delve "What are the latest advances in CRISPR?"
  delve "SaaS market size 2024"
  
  # Non-interactive research (no confirmation prompts)
  delve "What are neural networks?" --non-interactive
  delve "What is quantum computing?" -y
  
  # Research with local materials
  delve "Analyze this pitch deck" --input-dir ./pitch-materials/
  delve "Summarize these reports" --input-dir ~/Documents/research/
  
  # Session management
  delve resume session_1759356338
  delve latest
  delve --init --yes               Run initialization non-interactively

CONFIGURATION:
  Config files are stored in OS-appropriate locations:
    • macOS:   ~/.config/delve/
    • Linux:   ~/.config/delve/
    • Windows: %APPDATA%\\Delve\\

  Create custom configs:
    • ./src/utils/config-loader.sh init delve-config
    • ./src/utils/config-loader.sh init security-config
    • ./src/utils/config-loader.sh list    (see all configs)

  Add custom knowledge:
    • macOS:   ~/Library/Application Support/Delve/knowledge-base-custom/
    • Linux:   ~/.local/share/delve/knowledge-base-custom/
    • Windows: %LOCALAPPDATA%\\Delve\\knowledge-base-custom\\

RESULTS:
  Reports are saved to OS-appropriate data directories:
    • macOS:   ~/Library/Application Support/Delve/research-sessions/
    • Linux:   ~/.local/share/delve/research-sessions/
    • Windows: %LOCALAPPDATA%\\Delve\\research-sessions\\
  
  Use: ./src/utils/path-resolver.sh resolve session_dir (to find exact path)

DOCUMENTATION:
  Quick start:  docs/QUICK_REFERENCE.md
  User guide:   docs/USER_GUIDE.md
  Troubleshoot: docs/TROUBLESHOOTING.md
  README:       README.md

EOF
}

handle_research() {
    local question="$1"
    
    # Check initialization before running research
    if ! check_initialization; then
        run_initialization true
    fi
    
    # Check for --input-dir flag
    local input_dir=""
    if has_flag "input-dir"; then
        input_dir=$(get_flag "input-dir")
        
        # Validate input directory exists
        if [ ! -d "$input_dir" ]; then
            echo "Error: Input directory not found: $input_dir" >&2
            exit 1
        fi
        
        # Resolve to absolute path
        input_dir=$(cd "$input_dir" && pwd)
        
        echo "📁 Loading input files from: $input_dir"
        echo ""
        
        # Pass to delve-adaptive.sh via environment variable
        export DELVE_INPUT_DIR="$input_dir"
    fi
    
    # Check for --non-interactive or -y flag
    if has_flag "non-interactive" || has_flag "y"; then
        export DELVE_NON_INTERACTIVE=1
    fi
    
    # Call delve-adaptive.sh
    "$DELVE_ROOT/src/delve-adaptive.sh" "$question"
    
    # Show update notification after research
    if [ "${DELVE_NO_UPDATE_CHECK:-0}" != "1" ] && [ -f "$DELVE_ROOT/src/utils/version-checker.sh" ]; then
        # shellcheck disable=SC1091
        source "$DELVE_ROOT/src/utils/version-checker.sh"
        show_cached_notification || check_for_updates_async
    fi
}

main() {
    # Parse all CLI arguments
    parse_cli_args "$@"
    
    # Handle special flags first
    if has_flag "help" || has_flag "h"; then
        show_help
        return 0
    fi
    
    if has_flag "version" || has_flag "v"; then
        show_version
        return 0
    fi
    
    if has_flag "update"; then
        perform_update
        return 0
    fi
    
    if has_flag "check-update"; then
        if [ -f "$DELVE_ROOT/src/utils/version-checker.sh" ]; then
            # shellcheck disable=SC1091
            source "$DELVE_ROOT/src/utils/version-checker.sh"
            check_for_updates_sync
        else
            echo "Version checker not available"
            exit 1
        fi
        return 0
    fi
    
    if has_flag "no-update-check"; then
        export DELVE_NO_UPDATE_CHECK=1
    fi
    
    if has_flag "init"; then
        if has_flag "yes" || has_flag "y"; then
            run_initialization false
        else
            run_initialization true
        fi
        return 0
    fi
    
    # Get first positional argument (command or research question)
    local command
    command=$(get_arg 0)
    
    # Handle empty command
    if [ -z "$command" ]; then
        show_help
        return 0
    fi
    
    # Handle commands
    case "$command" in
        resume)
            # Check initialization before resuming
            if ! check_initialization; then
                run_initialization true
            fi
            
            local session_id
            session_id=$(get_arg 1)
            if [ -z "$session_id" ]; then
                echo "Error: resume requires a session ID" >&2
                exit 1
            fi
            
            "$DELVE_ROOT/src/delve-adaptive.sh" --resume "$session_id"
            
            # Show update notification after research
            if [ "${DELVE_NO_UPDATE_CHECK:-0}" != "1" ] && [ -f "$DELVE_ROOT/src/utils/version-checker.sh" ]; then
                # shellcheck disable=SC1091
                source "$DELVE_ROOT/src/utils/version-checker.sh"
                show_cached_notification || check_for_updates_async
            fi
            ;;
        sessions|list)
            # Use the formatted list from delve-adaptive.sh
            "$DELVE_ROOT/src/delve-adaptive.sh" --list
            ;;
        status)
            echo "Checking for running research sessions..."
            pgrep -fl "delve-adaptive" || echo "No active sessions"
            ;;
        latest)
            # Get session directory from path resolver (with fallback)
            local session_dir="$DELVE_ROOT/research-sessions"
            if [ -f "$DELVE_ROOT/src/utils/path-resolver.sh" ]; then
                # shellcheck disable=SC1091
                source "$DELVE_ROOT/src/utils/path-resolver.sh" 2>/dev/null
                local resolved
                # Use return code instead of string check
                if resolved=$(resolve_path "session_dir" 2>/dev/null) && [ -n "$resolved" ]; then
                    session_dir="$resolved"
                fi
            fi
            
            if [ -f "$session_dir/.latest" ]; then
                LATEST_SESSION=$(cat "$session_dir/.latest")
                LATEST_PATH="$session_dir/$LATEST_SESSION"
                
                if [ -d "$LATEST_PATH" ]; then
                    echo "Latest session: $LATEST_SESSION"
                    echo "Location: $LATEST_PATH"
                    echo ""
                    
                    # Show session metadata if available
                    if [ -f "$LATEST_PATH/session.json" ]; then
                        local question
                        question=$(jq -r '.research_question // "N/A"' "$LATEST_PATH/session.json" 2>/dev/null || echo "N/A")
                        local status
                        status=$(jq -r '.status // "unknown"' "$LATEST_PATH/session.json" 2>/dev/null || echo "unknown")
                        local created
                        created=$(jq -r '.created_at // "N/A"' "$LATEST_PATH/session.json" 2>/dev/null || echo "N/A")
                        
                        echo "Question: $question"
                        echo "Status: $status"
                        echo "Created: $created"
                        echo ""
                    fi
                    
                    # Show knowledge graph summary if available
                    if [ -f "$LATEST_PATH/knowledge-graph.json" ]; then
                        local entities=$(jq -r '.stats.total_entities // 0' "$LATEST_PATH/knowledge-graph.json" 2>/dev/null)
                        local claims=$(jq -r '.stats.total_claims // 0' "$LATEST_PATH/knowledge-graph.json" 2>/dev/null)
                        local confidence=$(jq -r '.confidence_scores.overall // 0' "$LATEST_PATH/knowledge-graph.json" 2>/dev/null)
                        local gaps=$(jq -r '.stats.unresolved_gaps // 0' "$LATEST_PATH/knowledge-graph.json" 2>/dev/null)
                        
                        echo "Progress:"
                        echo "  • Entities: $entities"
                        echo "  • Claims: $claims"
                        echo "  • Confidence: $confidence"
                        echo "  • Unresolved gaps: $gaps"
                        echo ""
                    fi
                    
                    # Show report if exists
                    if [ -f "$LATEST_PATH/research-report.md" ]; then
                        echo "✓ Report available: $LATEST_PATH/research-report.md"
                        echo ""
                        echo "View with:"
                        echo "  cat $LATEST_PATH/research-report.md"
                        echo "  open $LATEST_PATH/research-report.md"
                        echo ""
                        echo "Resume with:"
                        echo "  ./delve resume $LATEST_SESSION"
                    else
                        echo "⏳ Research in progress or not yet complete"
                        echo ""
                        echo "Resume with:"
                        echo "  ./delve resume $LATEST_SESSION"
                    fi
                else
                    echo "Error: Latest session directory not found: $LATEST_SESSION"
                    exit 1
                fi
            else
                echo "No research sessions yet. Start one with:"
                echo "  ./delve \"your research question\""
            fi
            ;;
        view-dashboard)
            # Get session directory (optional parameter)
            local session_arg
            session_arg=$(get_arg 1)
            local session_dir=""
            
            if [ -z "$session_arg" ]; then
                # No argument - use latest session
                local latest_file="$DELVE_ROOT/research-sessions/.latest"
                if [ ! -f "$latest_file" ]; then
                    echo "Error: No active session found" >&2
                    echo "Run a research query first: ./delve \"your question\"" >&2
                    exit 1
                fi
                local session_id
                session_id=$(cat "$latest_file")
                session_dir="$DELVE_ROOT/research-sessions/$session_id"
            elif [[ "$session_arg" == /* ]]; then
                # Absolute path provided
                session_dir="$session_arg"
            else
                # Session ID provided (with or without 'session_' prefix)
                local session_id="$session_arg"
                if [[ ! "$session_id" == session_* ]]; then
                    session_id="session_${session_id}"
                fi
                session_dir="$DELVE_ROOT/research-sessions/$session_id"
            fi
            
            # Validate session directory exists
            if [ ! -d "$session_dir" ]; then
                echo "Error: Session directory not found: $session_dir" >&2
                exit 1
            fi
            
            # Check if dashboard exists, generate if needed
            local dashboard_file="$session_dir/dashboard.html"
            if [ ! -f "$dashboard_file" ]; then
                echo "Generating dashboard..."
                if ! bash "$DELVE_ROOT/src/utils/dashboard-generator.sh" "$session_dir"; then
                    echo "Error: Failed to generate dashboard" >&2
                    exit 1
                fi
            fi
            
            # Generate dashboard metrics if missing
            if [ ! -f "$session_dir/dashboard-metrics.json" ]; then
                bash -c "source '$DELVE_ROOT/src/utils/dashboard-metrics.sh' && generate_dashboard_metrics '$session_dir'" 2>/dev/null || true
            fi
            
            # Find an available port (8890-8899)
            local port=""
            for p in {8890..8899}; do
                if ! lsof -i ":$p" >/dev/null 2>&1; then
                    port=$p
                    break
                fi
            done
            
            if [ -z "$port" ]; then
                echo "Error: No available ports in range 8890-8899" >&2
                echo "Try: pkill -f 'python.*http.server'" >&2
                exit 1
            fi
            
            # Start HTTP server in background
            echo "Starting HTTP server on port $port..."
            cd "$session_dir"
            python3 -m http.server "$port" > /dev/null 2>&1 &
            local server_pid=$!
            
            # Save PID for potential cleanup
            echo "$server_pid" > "$session_dir/.dashboard-server.pid"
            
            sleep 2
            
            # Open in browser with session ID parameter (prevents caching issues)
            local session_id
            session_id=$(basename "$session_dir")
            local dashboard_url="http://localhost:$port/dashboard.html?session=$session_id"
            echo "✅ Dashboard server started (PID: $server_pid)"
            echo "📊 Opening: $dashboard_url"
            echo ""
            echo "To stop the server later:"
            echo "  kill $server_pid"
            echo "  or: pkill -f 'python.*http.server.*$port'"
            echo ""
            
            if [[ "$OSTYPE" == "darwin"* ]]; then
                open "$dashboard_url"
            elif command -v xdg-open &> /dev/null; then
                xdg-open "$dashboard_url" &
            elif command -v explorer.exe &> /dev/null; then
                # WSL
                explorer.exe "$dashboard_url" 2>/dev/null
            else
                echo "Dashboard available at: $dashboard_url"
            fi
            ;;
        configure|config)
            echo "🔧 Delve Configuration"
            echo ""
            
            # Get user config directory
            if [ -f "$DELVE_ROOT/src/utils/config-loader.sh" ]; then
                source "$DELVE_ROOT/src/utils/config-loader.sh"
                
                echo "═══════════════════════════════════════════════════════"
                echo ""
                
                # Show user config location
                local user_config_dir=$(get_user_config_dir)
                echo "User Config Directory: $user_config_dir"
                echo ""
                
                # List configs
                "$DELVE_ROOT/src/utils/config-loader.sh" list
                echo ""
                
                echo "═══════════════════════════════════════════════════════"
                echo ""
                echo "Create custom config:"
                echo "  ./src/utils/config-loader.sh init <config-name>"
                echo ""
                echo "Edit config:"
                echo "  vim $user_config_dir/<config-name>.json"
                echo ""
                echo "View differences:"
                echo "  ./src/utils/config-loader.sh diff <config-name>"
                echo ""
                echo "Get help:"
                echo "  ./src/utils/config-loader.sh help"
            else
                echo "Error: Config loader not found"
                exit 1
            fi
            ;;
        *)
            # Research question - use adaptive system with optional --input-dir
            handle_research "$command"
            ;;
    esac
}

main "$@"
